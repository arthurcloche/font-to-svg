<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Bezier SDF Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: monospace;
        }
        canvas {
            border: 1px solid #444;
            display: block;
            margin: 20px 0;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .control {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        input[type="range"] {
            width: 150px;
        }
    </style>
</head>
<body>
    <h1>Simple Bezier SDF Test</h1>
    <p>Testing bezier curve SDF rendering with simple shapes</p>
    
    <div class="controls">
        <div class="control">
            <label>Animation Speed: <span id="speedValue">1.0</span></label>
            <input type="range" id="speedSlider" min="0" max="3" step="0.1" value="1.0">
        </div>
        <div class="control">
            <label>SDF Threshold: <span id="thresholdValue">0.5</span></label>
            <input type="range" id="thresholdSlider" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="control">
            <label>Shape: <span id="shapeValue">Letter A</span></label>
            <select id="shapeSelect">
                <option value="0">Letter A</option>
                <option value="1">Letter O</option>
                <option value="2">Heart Shape</option>
                <option value="3">Star Shape</option>
            </select>
        </div>
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div id="info">
        <h3>What you're seeing:</h3>
        <ul>
            <li><strong>Blue areas:</strong> Inside the shape (negative SDF values)</li>
            <li><strong>Red/orange areas:</strong> Outside the shape (positive SDF values)</li>
            <li><strong>Yellow edges:</strong> Exact boundaries (SDF = 0)</li>
            <li><strong>Animated control points:</strong> Show how bezier curves work</li>
        </ul>
        <p>This demonstrates the core SDF technique before integrating with your font parser.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            uniform vec2 u_resolution;
            varying vec2 v_position;
            
            void main() {
                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
                clipSpace.y *= -1.0;
                gl_Position = vec4(clipSpace, 0.0, 1.0);
                v_position = a_position;
            }
        `;

        // Fragment shader with multiple test shapes
        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_threshold;
            uniform int u_shapeType;
            
            varying vec2 v_position;
            
            float dot2(vec2 v) { return dot(v, v); }
            
            // Your existing bezier SDF function
            float bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    
                vec2 a = B - A;
                vec2 b = A - 2.0*B + C;
                vec2 c = a * 2.0;
                vec2 d = A - pos;
                float kk = 1.0/dot(b,b);
                float kx = kk * dot(a,b);
                float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
                float kz = kk * dot(d,a);      
                float res = 0.0;
                float p = ky - kx*kx;
                float p3 = p*p*p;
                float q = kx*(2.0*kx*kx-3.0*ky) + kz;
                float h = q*q + 4.0*p3;
                if (h >= 0.0) { 
                    h = sqrt(h);
                    vec2 x = (vec2(h,-h)-q)/2.0;
                    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
                    float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );
                    res = dot2(d + (c + b*t)*t);
                } else {
                    float z = sqrt(-p);
                    float v = acos( q/(p*z*2.0) ) / 3.0;
                    float m = cos(v);
                    float n = sin(v)*1.732050808;
                    vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);
                    res = min( dot2(d+(c+b*t.x)*t.x),
                                     dot2(d+(c+b*t.y)*t.y) );
                }
                return sqrt( res );
            }
            
            // Simple letter A approximation
            float letterA(vec2 p) {
                vec2 center = u_resolution * 0.5;
                p = p - center;
                
                // Left stroke
                vec2 A1 = vec2(-80.0, 100.0);
                vec2 B1 = vec2(-40.0, -50.0 + sin(u_time) * 10.0);
                vec2 C1 = vec2(0.0, -100.0);
                float d1 = bezier(p, A1, B1, C1);
                
                // Right stroke  
                vec2 A2 = vec2(0.0, -100.0);
                vec2 B2 = vec2(40.0, -50.0 + cos(u_time) * 10.0);
                vec2 C2 = vec2(80.0, 100.0);
                float d2 = bezier(p, A2, B2, C2);
                
                // Cross bar
                vec2 A3 = vec2(-30.0, 20.0);
                vec2 B3 = vec2(0.0, 25.0 + sin(u_time * 2.0) * 5.0);
                vec2 C3 = vec2(30.0, 20.0);
                float d3 = bezier(p, A3, B3, C3);
                
                return min(min(d1, d2), d3) - 10.0; // Stroke width
            }
            
            // Simple letter O approximation
            float letterO(vec2 p) {
                vec2 center = u_resolution * 0.5;
                p = p - center;
                
                // Outer circle using bezier curves (approximation)
                float angle = atan(p.y, p.x);
                float radius = 80.0 + sin(u_time + angle * 4.0) * 5.0;
                float outerDist = length(p) - radius;
                
                // Inner circle
                float innerRadius = 40.0 + cos(u_time * 1.5) * 3.0;
                float innerDist = length(p) - innerRadius;
                
                return max(outerDist, -innerDist);
            }
            
            // Heart shape using bezier curves
            float heart(vec2 p) {
                vec2 center = u_resolution * 0.5;
                p = p - center;
                p.y += 30.0; // Offset for better centering
                
                float scale = 0.7 + sin(u_time) * 0.1;
                p /= scale;
                
                // Left heart lobe
                vec2 A1 = vec2(-50.0, -30.0);
                vec2 B1 = vec2(-80.0, -60.0);
                vec2 C1 = vec2(-30.0, -80.0);
                float d1 = bezier(p, A1, B1, C1);
                
                // Right heart lobe
                vec2 A2 = vec2(50.0, -30.0);
                vec2 B2 = vec2(80.0, -60.0);
                vec2 C2 = vec2(30.0, -80.0);
                float d2 = bezier(p, A2, B2, C2);
                
                // Bottom point
                vec2 A3 = vec2(-30.0, -80.0);
                vec2 B3 = vec2(0.0, 20.0);
                vec2 C3 = vec2(30.0, -80.0);
                float d3 = bezier(p, A3, B3, C3);
                
                return min(min(d1, d2), d3) - 15.0;
            }
            
            // Star shape
            float star(vec2 p) {
                vec2 center = u_resolution * 0.5;
                p = p - center;
                
                float rotation = u_time * 0.5;
                float c = cos(rotation);
                float s = sin(rotation);
                p = vec2(p.x * c - p.y * s, p.x * s + p.y * c);
                
                // Create star using multiple bezier segments
                float minDist = 1000.0;
                
                for (int i = 0; i < 5; i++) {
                    float angle1 = float(i) * 6.28318 / 5.0;
                    float angle2 = float(i + 1) * 6.28318 / 5.0;
                    
                    vec2 outer1 = vec2(cos(angle1), sin(angle1)) * 60.0;
                    vec2 inner = vec2(cos((angle1 + angle2) * 0.5), sin((angle1 + angle2) * 0.5)) * 25.0;
                    vec2 outer2 = vec2(cos(angle2), sin(angle2)) * 60.0;
                    
                    float d = bezier(p, outer1, inner, outer2);
                    minDist = min(minDist, d);
                }
                
                return minDist - 8.0;
            }
            
            void main() {
                vec2 fragCoord = v_position;
                
                // Calculate SDF distance based on shape type
                float dist;
                if (u_shapeType == 0) {
                    dist = letterA(fragCoord);
                } else if (u_shapeType == 1) {
                    dist = letterO(fragCoord);
                } else if (u_shapeType == 2) {
                    dist = heart(fragCoord);
                } else {
                    dist = star(fragCoord);
                }
                
                // Color based on distance
                vec3 color;
                if (dist < 0.0) {
                    // Inside - blue gradient
                    float intensity = 1.0 - exp(dist * 0.02);
                    color = mix(vec3(0.1, 0.1, 0.3), vec3(0.3, 0.5, 1.0), intensity);
                } else {
                    // Outside - red gradient
                    float intensity = exp(-dist * 0.02);
                    color = mix(vec3(0.1, 0.1, 0.1), vec3(1.0, 0.4, 0.2), intensity);
                }
                
                // Edge highlighting
                float edge = 1.0 - smoothstep(0.0, 3.0, abs(dist));
                color = mix(color, vec3(1.0, 1.0, 0.0), edge * 0.8);
                
                // Add some visualization of the distance field
                float contours = sin(dist * 0.2) * 0.1;
                color += contours;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Shader compilation
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Create shaders and program
        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(vertexShader, fragmentShader);

        // Get locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const thresholdLocation = gl.getUniformLocation(program, 'u_threshold');
        const shapeTypeLocation = gl.getUniformLocation(program, 'u_shapeType');

        // Create geometry (full screen quad)
        const positions = new Float32Array([
            0, 0,
            canvas.width, 0,
            0, canvas.height,
            0, canvas.height,
            canvas.width, 0,
            canvas.width, canvas.height
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // UI controls
        const speedSlider = document.getElementById('speedSlider');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const shapeSelect = document.getElementById('shapeSelect');
        const speedValue = document.getElementById('speedValue');
        const thresholdValue = document.getElementById('thresholdValue');
        const shapeValue = document.getElementById('shapeValue');

        speedSlider.addEventListener('input', (e) => {
            speedValue.textContent = e.target.value;
        });

        thresholdSlider.addEventListener('input', (e) => {
            thresholdValue.textContent = e.target.value;
        });

        shapeSelect.addEventListener('change', (e) => {
            const shapes = ['Letter A', 'Letter O', 'Heart Shape', 'Star Shape'];
            shapeValue.textContent = shapes[parseInt(e.target.value)];
        });

        // Animation loop
        let startTime = Date.now();
        
        function render() {
            const currentTime = (Date.now() - startTime) / 1000.0;
            const speed = parseFloat(speedSlider.value);
            const threshold = parseFloat(thresholdSlider.value);
            const shapeType = parseInt(shapeSelect.value);
            
            // Clear canvas
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Use program
            gl.useProgram(program);

            // Set uniforms
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, currentTime * speed);
            gl.uniform1f(thresholdLocation, threshold);
            gl.uniform1i(shapeTypeLocation, shapeType);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        // Start rendering
        render();

        console.log('Simple Bezier SDF Test initialized');
        console.log('This demonstrates the core SDF concepts with test shapes');
        console.log('Next: integrate with your font parser for real glyph data');
    </script>
</body>
</html> 