<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Font SDF Integration Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .demo-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-group label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
        }
        
        .control-group input, .control-group select {
            padding: 8px;
            background: #3a3a3a;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
        }
        
        .control-group input[type="range"] {
            padding: 0;
        }
        
        .value-display {
            font-size: 11px;
            color: #ccc;
        }
        
        canvas {
            border: 2px solid #444;
            display: block;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .canvas-container {
            position: relative;
            display: inline-block;
        }
        
        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .info-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4a9eff;
        }
        
        .info-box h3 {
            margin: 0 0 10px 0;
            color: #4a9eff;
            font-size: 14px;
        }
        
        .info-box pre {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            font-size: 11px;
            overflow-x: auto;
            margin: 0;
        }
        
        .status {
            padding: 10px;
            background: #2a2a2a;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .status.loading { border-left: 4px solid #ffa500; }
        .status.ready { border-left: 4px solid #4caf50; }
        .status.error { border-left: 4px solid #f44336; }
        
        .font-loader {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .font-loader input[type="file"] {
            padding: 8px;
            background: #3a3a3a;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
        }
        
        .char-preview {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        
        .char-preview input {
            width: 60px;
            text-align: center;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <h1>Font-to-SDF Integration Demo</h1>
        
        <div class="font-loader">
            <label>Load Font:</label>
            <select id="fontSelect">
                <option value="bebas">Bebas Neue (TrueType)</option>
                <option value="obviously">Obviously Variable (TrueType)</option>
                <option value="inter">Inter Medium (TrueType)</option>
                <option value="sigma">Sigma Serif (CFF/OpenType)</option>
                <option value="upload">Upload Font File...</option>
            </select>
            <input type="file" id="fontUpload" accept=".ttf,.otf,.woff,.woff2" style="display: none;">
        </div>
        
        <div class="status" id="status">
            <strong>Status:</strong> <span id="statusText">Initializing...</span>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Character</label>
                <input type="text" id="charInput" value="A" maxlength="1">
                <div class="char-preview">
                    <button id="prevChar">←</button>
                    <button id="nextChar">→</button>
                    <span class="value-display">Unicode: <span id="unicodeDisplay">65</span></span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Scale</label>
                <input type="range" id="scaleSlider" min="0.1" max="3.0" step="0.1" value="1.0">
                <span class="value-display">Value: <span id="scaleValue">1.0</span></span>
            </div>
            
            <div class="control-group">
                <label>SDF Threshold</label>
                <input type="range" id="thresholdSlider" min="0.0" max="1.0" step="0.01" value="0.5">
                <span class="value-display">Value: <span id="thresholdValue">0.5</span></span>
            </div>
            
            <div class="control-group">
                <label>Smoothing</label>
                <input type="range" id="smoothingSlider" min="0.0" max="10.0" step="0.1" value="2.0">
                <span class="value-display">Value: <span id="smoothingValue">2.0</span></span>
            </div>
            
            <div class="control-group">
                <label>Visualization Mode</label>
                <select id="visualMode">
                    <option value="sdf">SDF Distance Field</option>
                    <option value="filled">Filled Shape</option>
                    <option value="outline">Outline Only</option>
                    <option value="bezier">Bezier Curves</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>2D Overlay</label>
                <select id="overlayMode">
                    <option value="none">None</option>
                    <option value="svg">SVG Path</option>
                    <option value="bezier">Bezier Points</option>
                    <option value="both">Both</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>SDF Strategy</label>
                <select id="sdfStrategy">
                    <option value="adaptive">Adaptive (Smart)</option>
                    <option value="optimal">Optimal (Original)</option>
                    <option value="midpoint">Midpoint (Safe)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Background</label>
                <select id="bgMode">
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                    <option value="transparent">Transparent Grid</option>
                </select>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
            <canvas id="overlayCanvas" class="overlay-canvas" width="800" height="600"></canvas>
        </div>
        
        <div class="info-panel">
            <div class="info-box">
                <h3>Font Information</h3>
                <pre id="fontInfo">Loading...</pre>
            </div>
            
            <div class="info-box">
                <h3>SDF Data</h3>
                <pre id="sdfInfo">Processing...</pre>
            </div>
        </div>
    </div>

    <!-- Include dependencies -->
    <script src="../font-parser.js"></script>
    <script src="sdf/font-sdf-renderer.js"></script>
    <script src="sdf/font-sdf-extension.js"></script>

    <script>
        // Global state
        let fontParser = null;
        let sdfRenderer = null;
        let sdfExtension = null;
        let gl = null;
        let program = null;
        let currentCharacter = 'A';
        let currentSdfData = null;
        let shaderUniforms = {
            controlPoints: null,
            contourInfo: null,
            bounds: null,
            totalSegments: null,
            totalContours: null
        };
        
        // Mouse interaction state
        let mouseX = 0;
        let mouseY = 0;
        let mousePressed = false;

        // DOM elements
        const elements = {
            canvas: document.getElementById('canvas'),
            overlayCanvas: document.getElementById('overlayCanvas'),
            status: document.getElementById('status'),
            statusText: document.getElementById('statusText'),
            fontSelect: document.getElementById('fontSelect'),
            fontUpload: document.getElementById('fontUpload'),
            charInput: document.getElementById('charInput'),
            prevChar: document.getElementById('prevChar'),
            nextChar: document.getElementById('nextChar'),
            unicodeDisplay: document.getElementById('unicodeDisplay'),
            scaleSlider: document.getElementById('scaleSlider'),
            scaleValue: document.getElementById('scaleValue'),
            thresholdSlider: document.getElementById('thresholdSlider'),
            thresholdValue: document.getElementById('thresholdValue'),
            smoothingSlider: document.getElementById('smoothingSlider'),
            smoothingValue: document.getElementById('smoothingValue'),
            visualMode: document.getElementById('visualMode'),
            overlayMode: document.getElementById('overlayMode'),
            sdfStrategy: document.getElementById('sdfStrategy'),
            bgMode: document.getElementById('bgMode'),
            fontInfo: document.getElementById('fontInfo'),
            sdfInfo: document.getElementById('sdfInfo')
        };

        // Initialize WebGL
        function initWebGL() {
            gl = elements.canvas.getContext('webgl');
            if (!gl) {
                updateStatus('error', 'WebGL not supported');
                return false;
            }

            // Enable extensions if available
            const ext = gl.getExtension('OES_standard_derivatives');
            if (!ext) {
                console.warn('OES_standard_derivatives not available');
            }

            return true;
        }

        // Load font by name
        async function loadFont(fontName = 'bebas') {
            try {
                const fontPaths = {
                    'bebas': '../fonts/BebasNeue-Regular.ttf',
                    'obviously': '../fonts/Obviously-Variable.ttf', 
                    'inter': '../fonts/Inter_28pt-Medium.ttf',
                    'sigma': '../fonts/SigmaSerif-Headline.otf'
                };
                
                const fontPath = fontPaths[fontName];
                if (!fontPath) {
                    throw new Error(`Unknown font: ${fontName}`);
                }
                
                updateStatus('loading', `Loading ${fontName} font...`);
                fontParser = new FontParser();
                await fontParser.from(fontPath);
                
                // Create both old and new SDF systems for comparison
                sdfRenderer = new FontSDFRenderer(fontParser);
                sdfExtension = new FontSDFExtension(fontParser, {
                    enableDebugLogging: true,
                    cubicToQuadStrategy: elements.sdfStrategy.value
                });
                
                updateFontInfo();
                updateStatus('ready', `${fontName} font loaded successfully`);
                return true;
            } catch (error) {
                updateStatus('error', `Failed to load font: ${error.message}`);
                return false;
            }
        }

        // Update font information display
        function updateFontInfo() {
            if (!fontParser) return;
            
            const fontData = fontParser.data;
            const info = `Font: ${fontData.name}
Units per EM: ${fontData.unitsPerEm}
Variable Font: ${fontData.isVariable}
Glyphs: ${fontData.numGlyphs}
Tables: ${fontData.tables.join(', ')}

Bounds:
  X: ${fontData.bounds.xMin} to ${fontData.bounds.xMax}
  Y: ${fontData.bounds.yMin} to ${fontData.bounds.yMax}

Metrics:
  Ascender: ${fontData.metrics.ascender}
  Descender: ${fontData.metrics.descender}
  Line Gap: ${fontData.metrics.lineGap}`;
            
            elements.fontInfo.textContent = info;
        }

        // Update SDF information display
        function updateSdfInfo() {
            if (!currentSdfData) return;
            
            const info = `Character: "${currentSdfData.character}"
Glyph ID: ${currentSdfData.glyphId}
Contours: ${currentSdfData.contours.length}

Bounds:
  Width: ${currentSdfData.bounds.width.toFixed(2)}
  Height: ${currentSdfData.bounds.height.toFixed(2)}
  X: ${currentSdfData.bounds.minX.toFixed(2)} to ${currentSdfData.bounds.maxX.toFixed(2)}
  Y: ${currentSdfData.bounds.minY.toFixed(2)} to ${currentSdfData.bounds.maxY.toFixed(2)}

Contour Details:
${currentSdfData.contours.map((contour, i) => {
  const segmentTypes = contour.segments.reduce((acc, seg) => {
    acc[seg.type] = (acc[seg.type] || 0) + 1;
    return acc;
  }, {});
  const typeStr = Object.entries(segmentTypes).map(([type, count]) => `${count} ${type}`).join(', ');
  return `  Contour ${i}: ${contour.segments.length} segments (${typeStr}), winding: ${contour.windingOrder}`;
}).join('\n')}`;
            
            elements.sdfInfo.textContent = info;
        }

        // Create shader program
        function createShaderProgram() {
            const vertexShaderSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                
                uniform vec2 u_resolution;
                uniform float u_scale;
                uniform vec2 u_offset;
                
                varying vec2 v_texCoord;
                varying vec2 v_fragCoord;
                
                void main() {
                    // Pass through screen coordinates for fragment shader
                    v_fragCoord = a_position;
                    v_texCoord = a_texCoord;
                    
                    // Convert to normalized device coordinates
                    vec2 position = (a_position / u_resolution) * 2.0 - 1.0;
                    position.y *= -1.0; // Flip Y for WebGL coordinate system
                    
                    gl_Position = vec4(position, 0.0, 1.0);
                }
            `;

            const fragmentShaderSource = `
                precision highp float;
                
                ${sdfRenderer.generateShaderCode()}
                
                uniform vec2 u_resolution;
                uniform float u_scale;
                uniform vec2 u_offset;
                uniform float u_threshold;
                uniform float u_smoothing;
                uniform int u_visualMode;
                uniform int u_bgMode;
                uniform int u_fontType; // 0 = TrueType, 1 = CFF
                uniform vec3 u_mouse; // x, y, pressed
                
                varying vec2 v_texCoord;
                varying vec2 v_fragCoord;
                
                void main() {
                    // Transform screen coordinates to glyph space
                    // Font-type-specific Y coordinate handling
                    vec2 screenPos = v_fragCoord;
                    
                    // TrueType: SVG already has flipY=true, so no additional flip needed
                    // CFF: SVG has flipY=false, so we need to flip Y in shader
                    if (u_fontType == 1) { // CFF fonts
                        screenPos.y = u_resolution.y - screenPos.y;
                    }
                    // TrueType fonts (u_fontType == 0): no Y flip needed
                    
                    vec2 pos = (screenPos - u_offset) / u_scale;
                    
                    // Calculate SDF distance
                    float dist = fontSDF(pos);
                    
                    vec3 color = vec3(0.0);
                    float alpha = 1.0;
                    
                    // Background
                    if (u_bgMode == 0) {
                        // Dark background
                        color = vec3(0.1);
                    } else if (u_bgMode == 1) {
                        // Light background
                        color = vec3(0.9);
                    } else {
                        // Transparent grid
                        vec2 grid = floor(v_fragCoord / 20.0);
                        float checker = mod(grid.x + grid.y, 2.0);
                        color = vec3(0.2 + checker * 0.1);
                    }
                    
                    if (u_visualMode == 0) {
                        // SDF Distance Field visualization
                        if (dist < 0.0) {
                            // Inside - blue gradient
                            float intensity = 1.0 - exp(dist * 0.01);
                            color = mix(color, vec3(0.2, 0.4, 1.0), intensity);
                        } else {
                            // Outside - red gradient
                            float intensity = exp(-dist * 0.01);
                            color = mix(color, vec3(1.0, 0.3, 0.2), intensity);
                        }
                        
                        // Edge highlighting
                        float edge = smoothstep(2.0, 0.0, abs(dist));
                        color = mix(color, vec3(1.0, 1.0, 0.0), edge * 0.8);
                        
                    } else if (u_visualMode == 1) {
                        // Filled shape - clean solid fill
                        if (dist < 0.0) {
                            // Inside the shape - solid white
                            color = vec3(1.0, 1.0, 1.0);
                        } else {
                            // Outside - apply anti-aliasing at edges
                            float edge = 1.0 - smoothstep(0.0, u_smoothing, dist);
                            color = mix(color, vec3(1.0, 1.0, 1.0), edge);
                        }
                        
                    } else if (u_visualMode == 2) {
                        // Outline only
                        float outline = 1.0 - smoothstep(0.0, u_smoothing, abs(dist));
                        color = mix(color, vec3(1.0), outline);
                        
                    } else if (u_visualMode == 3) {
                        // Bezier curves visualization
                        // Show control points and curves
                        float curves = 0.0;
                        
                        // Use constant loops for WebGL 1.0 compatibility
                        for (int i = 0; i < 24; i++) {
                            if (i >= u_totalSegments) break;
                            
                            vec2 A = getControlPoint(i * 3);
                            vec2 B = getControlPoint(i * 3 + 1);
                            vec2 C = getControlPoint(i * 3 + 2);
                            
                            // Highlight control points
                            float dA = length(pos - A);
                            float dB = length(pos - B);
                            float dC = length(pos - C);
                            
                            if (dA < 5.0) curves = max(curves, 1.0 - dA / 5.0);
                            if (dB < 3.0) curves = max(curves, (1.0 - dB / 3.0) * 0.7);
                            if (dC < 5.0) curves = max(curves, 1.0 - dC / 5.0);
                        }
                        
                        // Show curve outlines
                        float outline = 1.0 - smoothstep(0.0, 2.0, abs(dist));
                        curves = max(curves, outline * 0.5);
                        
                        color = mix(color, vec3(0.8, 1.0, 0.8), curves);
                    }
                    
                    // Interactive SDF visualization when mouse is pressed
                    if (u_mouse.z > 0.5) {
                        vec2 mouseScreenPos = u_mouse.xy;
                        // Apply same font-type-specific Y handling for mouse coordinates
                        if (u_fontType == 1) { // CFF fonts
                            mouseScreenPos.y = u_resolution.y - mouseScreenPos.y;
                        }
                        vec2 mousePos = (mouseScreenPos - u_offset) / u_scale;
                        float mouseDist = fontSDF(mousePos);
                        
                        // Draw circle at mouse position showing SDF value
                        float circleRadius = 20.0 / u_scale; // Fixed pixel radius
                        float distToMouse = length(pos - mousePos);
                        
                        // Yellow circle outline at mouse position
                        float mouseCircle = 1.0 - smoothstep(0.0, 2.0 / u_scale, abs(distToMouse - circleRadius));
                        color = mix(color, vec3(1.0, 1.0, 0.0), mouseCircle);
                        
                        // Yellow dot at mouse center
                        float mouseDot = 1.0 - smoothstep(0.0, 5.0 / u_scale, distToMouse);
                        color = mix(color, vec3(1.0, 1.0, 0.0), mouseDot);
                        
                        // Visualize SDF isolines around mouse
                        float sdfAtPos = fontSDF(pos);
                        float isoline = 1.0 - smoothstep(0.0, 1.0 / u_scale, abs(abs(sdfAtPos) - abs(mouseDist)) - 1.0 / u_scale);
                        color = mix(color, vec3(1.0, 1.0, 0.0), isoline * 0.3);
                    }
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `;

            // Create and compile shaders
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            if (!vertexShader || !fragmentShader) {
                return null;
            }

            // Create program
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        // Helper function to create shader
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Update character and regenerate SDF
        function updateCharacter(char) {
            if (!fontParser || !sdfExtension) return;
            
            currentCharacter = char;
            elements.charInput.value = char;
            elements.unicodeDisplay.textContent = char.charCodeAt(0);
            
            // Update SDF extension strategy
            sdfExtension.cubicToQuadStrategy = elements.sdfStrategy.value;
            
            // DEBUG: Comprehensive font analysis
            console.log(`\n=== COMPREHENSIVE FONT ANALYSIS FOR "${char}" ===`);
            console.log('Font Type:', fontParser.fontType);
            
            // Test SVG generation
            const svgPath = fontParser.glyphToSVGPath(char, {
                scale: 1,
                flipY: false, // Match the coordinates used in SDF
                offsetX: 0,
                offsetY: 0
            });
            console.log('SVG Path:', svgPath ? svgPath.substring(0, 100) + '...' : 'null');
            console.log('SVG Path length:', svgPath ? svgPath.length : 'null');
            
            // Test direct glyph parsing
            const glyphId = fontParser.getGlyphId(char);
            const rawGlyph = fontParser.parseGlyph(glyphId);
            console.log('Raw Glyph ID:', glyphId);
            console.log('Raw Glyph contours:', rawGlyph ? rawGlyph.contours.length : 'null');
            if (rawGlyph?.contours) {
                rawGlyph.contours.forEach((contour, i) => {
                    console.log(`  Raw Contour ${i}: ${contour.length} points`);
                });
            }
            
            // Extract SDF data using font-type-aware extension
            currentSdfData = sdfExtension.extractSDFData(char);
            console.log('SDF Extension result - contours:', currentSdfData.contours.length);
            
            // Detailed analysis of what we got
            console.log('=== FINAL SDF DATA ANALYSIS ===');
            console.log('Total contours:', currentSdfData.contours.length);
            console.log('Bounds:', currentSdfData.bounds);
            
            currentSdfData.contours.forEach((contour, i) => {
                console.log(`\nContour ${i}:`);
                console.log(`  - Winding: ${contour.windingOrder}`);
                console.log(`  - Segments: ${contour.segments.length}`);
                console.log(`  - Segment types:`, contour.segments.map(s => s.type).join(', '));
                
                // Check for critical issues
                if (contour.segments.length === 0) {
                    console.error(`  ❌ CRITICAL: No segments in contour ${i}!`);
                } else if (contour.segments.length < 3) {
                    console.warn(`  ⚠️ WARNING: Very few segments in contour ${i} (${contour.segments.length})`);
                }
                
                // Show first few segments for debugging
                contour.segments.slice(0, 3).forEach((seg, j) => {
                    console.log(`  - Segment ${j}: ${seg.type} (${seg.start.x.toFixed(1)},${seg.start.y.toFixed(1)}) -> (${seg.end.x.toFixed(1)},${seg.end.y.toFixed(1)})`);
                    if (seg.control) {
                        console.log(`    Control: (${seg.control.x.toFixed(1)},${seg.control.y.toFixed(1)})`);
                    }
                });
                
                if (contour.segments.length > 3) {
                    console.log(`  - ... and ${contour.segments.length - 3} more segments`);
                }
            });
            
            // Check for specific problems
            if (currentSdfData.contours.length === 0) {
                console.error('❌ CRITICAL: No contours extracted! This will cause empty screen.');
            } else if (currentSdfData.contours.every(c => c.segments.length === 0)) {
                console.error('❌ CRITICAL: All contours are empty! This will cause empty screen.');
            } else if (currentSdfData.bounds.width === 0 || currentSdfData.bounds.height === 0) {
                console.error('❌ CRITICAL: Zero-size bounds! This will cause rendering issues.');
                console.log('Bounds details:', {
                    width: currentSdfData.bounds.width,
                    height: currentSdfData.bounds.height,
                    minX: currentSdfData.bounds.minX,
                    maxX: currentSdfData.bounds.maxX,
                    minY: currentSdfData.bounds.minY,
                    maxY: currentSdfData.bounds.maxY
                });
            }
            
            console.log('=== END COMPREHENSIVE ANALYSIS ===\n');
            
            updateSdfInfo();
            
            // Use new extension for shader data preparation (fixed coordinate system)
            const shaderData = sdfExtension.prepareShaderData(currentSdfData);
            
            // Update uniform data
            shaderUniforms = {
                controlPoints: shaderData.controlPoints,
                contourInfo: shaderData.contourInfo,
                bounds: shaderData.bounds,
                totalSegments: shaderData.totalSegments,
                totalContours: shaderData.totalContours
            };
            
            console.log('Shader uniforms summary:', {
                totalSegments: shaderUniforms.totalSegments,
                totalContours: shaderUniforms.totalContours,
                boundsArray: Array.from(shaderUniforms.bounds),
                hasControlPoints: !!shaderUniforms.controlPoints,
                controlPointsLength: shaderUniforms.controlPoints ? shaderUniforms.controlPoints.length : 0
            });
            
            render();
        }

        // Render 2D overlay
        function render2DOverlay() {
            if (!currentSdfData) {
                console.log('render2DOverlay: No SDF data');
                return;
            }
            
            const ctx = elements.overlayCanvas.getContext('2d');
            const overlayMode = elements.overlayMode.value;
            
            console.log('render2DOverlay: mode =', overlayMode);
            
            // Clear overlay
            ctx.clearRect(0, 0, elements.overlayCanvas.width, elements.overlayCanvas.height);
            
            if (overlayMode === 'none') return;
            
            // Match the same scaling and positioning as WebGL
            const scale = parseFloat(elements.scaleSlider.value);
            const glyphWidth = currentSdfData.bounds.width;
            const glyphHeight = currentSdfData.bounds.height;
            const canvasWidth = elements.canvas.width;
            const canvasHeight = elements.canvas.height;
            
            const padding = 50;
            const maxScale = Math.min(
                (canvasWidth - padding * 2) / glyphWidth,
                (canvasHeight - padding * 2) / glyphHeight
            );
            const finalScale = scale * maxScale * 0.8;
            
            const glyphCenterX = (currentSdfData.bounds.minX + currentSdfData.bounds.maxX) / 2;
            const glyphCenterY = (currentSdfData.bounds.minY + currentSdfData.bounds.maxY) / 2;
            const centerX = canvasWidth / 2 - glyphCenterX * finalScale;
            const centerY = canvasHeight / 2 - glyphCenterY * finalScale;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            // Adjust canvas transform based on font type coordinate system
            const flipY = fontParser.fontType === 'truetype';
            const yScale = flipY ? finalScale : -finalScale; // CFF needs Y-flip in canvas
            ctx.scale(finalScale, yScale);
            
            // Draw SVG path
            if (overlayMode === 'svg' || overlayMode === 'both') {
                // Use same font-type-specific Y-flip as SDF extraction
                const flipY = fontParser.fontType === 'truetype';
                const svgPath = fontParser.glyphToSVGPath(currentCharacter, {
                    scale: 1,
                    flipY: flipY,
                    offsetX: 0,
                    offsetY: 0
                });
                
                if (svgPath) {
                    const path2D = new Path2D(svgPath);
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                    ctx.lineWidth = 2 / finalScale;
                    ctx.stroke(path2D);
                    
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    ctx.fill(path2D);
                }
            }
            
            // Draw bezier control points and curves
            if (overlayMode === 'bezier' || overlayMode === 'both') {
                currentSdfData.contours.forEach((contour, contourIdx) => {
                    const color = `hsl(${contourIdx * 60}, 70%, 60%)`;
                    
                    contour.segments.forEach((segment, segIdx) => {
                        // Different visualization for different segment types
                        if (segment.type === 'linear') {
                            // Linear segments - draw as straight lines with square markers
                            ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                            ctx.lineWidth = 2 / finalScale;
                            ctx.beginPath();
                            ctx.moveTo(segment.start.x, segment.start.y);
                            ctx.lineTo(segment.end.x, segment.end.y);
                            ctx.stroke();
                            
                            // Square markers for linear segments
                            const markerSize = 4 / finalScale;
                            ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                            ctx.fillRect(segment.start.x - markerSize/2, segment.start.y - markerSize/2, markerSize, markerSize);
                            ctx.fillRect(segment.end.x - markerSize/2, segment.end.y - markerSize/2, markerSize, markerSize);
                            
                        } else {
                            // Quadratic segments - original bezier visualization
                            ctx.fillStyle = color;
                            ctx.strokeStyle = color;
                            
                            // Start point (circle)
                            ctx.beginPath();
                            ctx.arc(segment.start.x, segment.start.y, 3 / finalScale, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Control point (yellow diamond)
                            ctx.save();
                            ctx.translate(segment.control.x, segment.control.y);
                            ctx.rotate(Math.PI / 4);
                            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                            const diamond = 2 / finalScale;
                            ctx.fillRect(-diamond, -diamond, diamond * 2, diamond * 2);
                            ctx.restore();
                            
                            // End point (circle)
                            ctx.beginPath();
                            ctx.arc(segment.end.x, segment.end.y, 3 / finalScale, 0, Math.PI * 2);
                            ctx.fillStyle = color;
                            ctx.fill();
                            
                            // Draw control lines (dashed)
                            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                            ctx.lineWidth = 1 / finalScale;
                            ctx.setLineDash([5 / finalScale, 5 / finalScale]);
                            ctx.beginPath();
                            ctx.moveTo(segment.start.x, segment.start.y);
                            ctx.lineTo(segment.control.x, segment.control.y);
                            ctx.lineTo(segment.end.x, segment.end.y);
                            ctx.stroke();
                            ctx.setLineDash([]); // Reset line dash
                            
                            // Draw bezier curve (thick)
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 2 / finalScale;
                            ctx.beginPath();
                            ctx.moveTo(segment.start.x, segment.start.y);
                            ctx.quadraticCurveTo(
                                segment.control.x, segment.control.y,
                                segment.end.x, segment.end.y
                            );
                            ctx.stroke();
                        }
                        
                        // Add segment index labels for debugging
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = `${12 / finalScale}px monospace`;
                        ctx.textAlign = 'center';
                        const labelX = (segment.start.x + segment.end.x) / 2;
                        const labelY = (segment.start.y + segment.end.y) / 2;
                        ctx.fillText(`${segIdx}`, labelX, labelY);
                    });
                });
            }
            
            ctx.restore();
        }

        // Render frame
        function render() {
            if (!gl || !program || !currentSdfData) return;

            // Clear canvas
            gl.viewport(0, 0, elements.canvas.width, elements.canvas.height);
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Use program
            gl.useProgram(program);

            // Set up geometry (full screen quad)
            const positions = new Float32Array([
                0, 0,
                elements.canvas.width, 0,
                0, elements.canvas.height,
                0, elements.canvas.height,
                elements.canvas.width, 0,
                elements.canvas.width, elements.canvas.height
            ]);

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Set uniforms - fix scaling and centering
            const scale = parseFloat(elements.scaleSlider.value);
            
            // Calculate proper bounds and centering
            const glyphWidth = currentSdfData.bounds.width;
            const glyphHeight = currentSdfData.bounds.height;
            const canvasWidth = elements.canvas.width;
            const canvasHeight = elements.canvas.height;
            
            // Auto-scale to fit canvas with some padding
            const padding = 50;
            const maxScale = Math.min(
                (canvasWidth - padding * 2) / glyphWidth,
                (canvasHeight - padding * 2) / glyphHeight
            );
            const finalScale = scale * maxScale * 0.8; // Apply user scale on top of auto-scale
            
            // Center the glyph properly - account for glyph bounds offset
            const glyphCenterX = (currentSdfData.bounds.minX + currentSdfData.bounds.maxX) / 2;
            const glyphCenterY = (currentSdfData.bounds.minY + currentSdfData.bounds.maxY) / 2;
            const centerX = canvasWidth / 2 - glyphCenterX * finalScale;
            const centerY = canvasHeight / 2 - glyphCenterY * finalScale;

            gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), canvasWidth, canvasHeight);
            gl.uniform1f(gl.getUniformLocation(program, 'u_scale'), finalScale);
            gl.uniform2f(gl.getUniformLocation(program, 'u_offset'), centerX, centerY);
            gl.uniform1f(gl.getUniformLocation(program, 'u_threshold'), parseFloat(elements.thresholdSlider.value));
            gl.uniform1f(gl.getUniformLocation(program, 'u_smoothing'), parseFloat(elements.smoothingSlider.value));
            gl.uniform1i(gl.getUniformLocation(program, 'u_visualMode'), elements.visualMode.selectedIndex);
            gl.uniform1i(gl.getUniformLocation(program, 'u_bgMode'), elements.bgMode.selectedIndex);
            gl.uniform1i(gl.getUniformLocation(program, 'u_fontType'), fontParser.fontType === 'cff' ? 1 : 0);
            gl.uniform3f(gl.getUniformLocation(program, 'u_mouse'), mouseX, mouseY, mousePressed ? 1.0 : 0.0);

            // Set SDF data uniforms - WebGL 1.0 compatible
            if (shaderUniforms.controlPoints) {
                // Pass flattened arrays directly
                gl.uniform1fv(gl.getUniformLocation(program, 'u_controlPoints'), 
                             shaderUniforms.controlPoints);
            }
            
            if (shaderUniforms.contourInfo) {
                gl.uniform1fv(gl.getUniformLocation(program, 'u_contourInfo'), 
                             shaderUniforms.contourInfo);
            }

            gl.uniform1i(gl.getUniformLocation(program, 'u_totalSegments'), shaderUniforms.totalSegments);
            gl.uniform1i(gl.getUniformLocation(program, 'u_totalContours'), shaderUniforms.totalContours);

            // Draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Render 2D overlay
            render2DOverlay();
        }

        // Update status display
        function updateStatus(type, message) {
            elements.status.className = `status ${type}`;
            elements.statusText.textContent = message;
        }

        // Event listeners
        function setupEventListeners() {
            // Character input
            elements.charInput.addEventListener('input', (e) => {
                const char = e.target.value.slice(-1) || 'A';
                updateCharacter(char);
            });

            // Character navigation
            elements.prevChar.addEventListener('click', () => {
                const currentCode = currentCharacter.charCodeAt(0);
                const newCode = Math.max(32, currentCode - 1);
                updateCharacter(String.fromCharCode(newCode));
            });

            elements.nextChar.addEventListener('click', () => {
                const currentCode = currentCharacter.charCodeAt(0);
                const newCode = Math.min(126, currentCode + 1);
                updateCharacter(String.fromCharCode(newCode));
            });

            // Sliders
            elements.scaleSlider.addEventListener('input', (e) => {
                elements.scaleValue.textContent = e.target.value;
                render();
            });

            elements.thresholdSlider.addEventListener('input', (e) => {
                elements.thresholdValue.textContent = e.target.value;
                render();
            });

            elements.smoothingSlider.addEventListener('input', (e) => {
                elements.smoothingValue.textContent = e.target.value;
                render();
            });

            // Select controls
            elements.visualMode.addEventListener('change', render);
            elements.overlayMode.addEventListener('change', render);
            elements.sdfStrategy.addEventListener('change', () => {
                updateCharacter(currentCharacter); // Regenerate with new strategy
            });
            elements.bgMode.addEventListener('change', render);

            // Font selection
            elements.fontSelect.addEventListener('change', async (e) => {
                if (e.target.value === 'upload') {
                    elements.fontUpload.style.display = 'block';
                    elements.fontUpload.click();
                } else {
                    // Load selected font
                    const success = await loadFont(e.target.value);
                    if (success) {
                        // Update SDF extension with new font
                        sdfExtension = new FontSDFExtension(fontParser, {
                            enableDebugLogging: true,
                            cubicToQuadStrategy: elements.sdfStrategy.value
                        });
                        
                        // Recreate shader program with new font
                        if (!createShaderProgram()) {
                            updateStatus('error', 'Failed to create shader program');
                            return;
                        }
                        // Update current character with new font
                        updateCharacter(currentCharacter);
                    }
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                
                if (e.key === 'ArrowLeft') {
                    elements.prevChar.click();
                } else if (e.key === 'ArrowRight') {
                    elements.nextChar.click();
                } else if (e.key.length === 1 && e.key.match(/[a-zA-Z0-9]/)) {
                    updateCharacter(e.key);
                }
            });

            // Mouse interaction for SDF visualization
            elements.canvas.addEventListener('mousemove', (e) => {
                const rect = elements.canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                if (mousePressed) {
                    render(); // Re-render when mouse moves while pressed
                }
            });

            elements.canvas.addEventListener('mousedown', (e) => {
                mousePressed = true;
                render();
            });

            elements.canvas.addEventListener('mouseup', (e) => {
                mousePressed = false;
                render();
            });

            elements.canvas.addEventListener('mouseleave', (e) => {
                mousePressed = false;
                render();
            });
        }

        // Initialize everything
        async function init() {
            updateStatus('loading', 'Initializing WebGL...');
            
            if (!initWebGL()) {
                return;
            }

            updateStatus('loading', 'Loading font...');
            if (!await loadFont('bebas')) {
                return;
            }

            updateStatus('loading', 'Creating shaders...');
            if (!createShaderProgram()) {
                updateStatus('error', 'Failed to create shader program');
                return;
            }

            setupEventListeners();
            updateCharacter('A');
            
            updateStatus('ready', 'Ready! Use arrow keys or type to change character');
        }

        // Start the demo
        init().catch(error => {
            console.error('Initialization failed:', error);
            updateStatus('error', `Initialization failed: ${error.message}`);
        });
    </script>
</body>
</html> 