<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Font-to-SDF WebGL Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: monospace;
        }
        canvas {
            border: 1px solid #444;
            display: block;
            margin: 20px 0;
        }
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        input[type="range"] {
            width: 150px;
        }
    </style>
</head>
<body>
    <h1>Font-to-SDF WebGL Demo</h1>
    
    <div class="controls">
        <div class="slider-group">
            <label>Scale: <span id="scaleValue">1.0</span></label>
            <input type="range" id="scaleSlider" min="0.1" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="slider-group">
            <label>Time: <span id="timeValue">0.0</span></label>
            <input type="range" id="timeSlider" min="0" max="10" step="0.1" value="0">
        </div>
        <button id="resetBtn">Reset</button>
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div id="info">
        <p>WebGL SDF Demo - Ready to render bezier curves</p>
        <p>Next: Add bezier curve data and SDF calculations</p>
    </div>

    <script>
        // WebGL Setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Vertex shader - simple quad rendering
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            
            uniform vec2 u_resolution;
            uniform float u_scale;
            
            varying vec2 v_texCoord;
            varying vec2 v_fragCoord;
            
            void main() {
                // Convert from pixels to normalized device coordinates
                vec2 position = (a_position * u_scale) / u_resolution * 2.0 - 1.0;
                position.y *= -1.0; // Flip Y for screen coordinates
                
                gl_Position = vec4(position, 0.0, 1.0);
                v_texCoord = a_texCoord;
                v_fragCoord = a_position * u_scale;
            }
        `;

        // Fragment shader - SDF rendering foundation
        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_scale;
            
            varying vec2 v_texCoord;
            varying vec2 v_fragCoord;
            
            // Utility functions
            float dot2(vec2 v) { 
                return dot(v, v); 
            }
            
            // Basic circle SDF for testing
            float sdCircle(vec2 p, float r) {
                return length(p) - r;
            }
            
            // Bezier curve SDF (from your existing code)
            float bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    
                vec2 a = B - A;
                vec2 b = A - 2.0*B + C;
                vec2 c = a * 2.0;
                vec2 d = A - pos;
                float kk = 1.0/dot(b,b);
                float kx = kk * dot(a,b);
                float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
                float kz = kk * dot(d,a);      
                float res = 0.0;
                float p = ky - kx*kx;
                float p3 = p*p*p;
                float q = kx*(2.0*kx*kx-3.0*ky) + kz;
                float h = q*q + 4.0*p3;
                if (h >= 0.0) { 
                    h = sqrt(h);
                    vec2 x = (vec2(h,-h)-q)/2.0;
                    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
                    float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );
                    res = dot2(d + (c + b*t)*t);
                } else {
                    float z = sqrt(-p);
                    float v = acos( q/(p*z*2.0) ) / 3.0;
                    float m = cos(v);
                    float n = sin(v)*1.732050808;
                    vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);
                    res = min( dot2(d+(c+b*t.x)*t.x),
                                     dot2(d+(c+b*t.y)*t.y) );
                    // the third root cannot be the closest
                    // res = min(res,dot(d+(c+b*t.z)*t.z));
                }
                return sqrt( res );
            }
            
            // Test scene with fake bezier curves
            float sceneSDF(vec2 p) {
                vec2 center = u_resolution * 0.5;
                p = p - center;
                
                // Test bezier curve 1 - simple arc
                vec2 A1 = vec2(-100.0, 0.0);
                vec2 B1 = vec2(0.0, -100.0 + sin(u_time) * 30.0);
                vec2 C1 = vec2(100.0, 0.0);
                float d1 = bezier(p, A1, B1, C1);
                
                // Test bezier curve 2 - S-curve
                vec2 A2 = vec2(-80.0, 50.0);
                vec2 B2 = vec2(0.0, 100.0 + cos(u_time) * 20.0);
                vec2 C2 = vec2(80.0, 50.0);
                float d2 = bezier(p, A2, B2, C2);
                
                // Test circle for comparison
                float d3 = sdCircle(p - vec2(0.0, -100.0), 30.0);
                
                // Combine distances (union)
                return min(min(d1, d2), d3);
            }
            
            void main() {
                vec2 fragCoord = v_fragCoord;
                
                // Calculate SDF distance
                float dist = sceneSDF(fragCoord);
                
                // Convert distance to color with antialiasing
                float smoothWidth = 2.0;
                float alpha = 1.0 - smoothstep(0.0, smoothWidth, abs(dist));
                
                // Color based on distance
                vec3 color;
                if (dist < 0.0) {
                    // Inside - blue
                    color = vec3(0.2, 0.4, 1.0);
                } else {
                    // Outside - show distance field
                    float normalized = exp(-dist * 0.01);
                    color = vec3(normalized, normalized * 0.5, normalized * 0.2);
                }
                
                // Edge highlighting
                float edge = smoothstep(1.0, 0.0, abs(dist));
                color = mix(color, vec3(1.0, 1.0, 0.0), edge * 0.5);
                
                gl_FragColor = vec4(color, alpha);
            }
        `;

        // Shader compilation utilities
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error('Shader compilation error: ' + error);
            }
            
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                const error = gl.getProgramInfoLog(program);
                gl.deleteProgram(program);
                throw new Error('Program linking error: ' + error);
            }
            
            return program;
        }

        // Create shaders and program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Get attribute and uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const scaleLocation = gl.getUniformLocation(program, 'u_scale');

        // Create quad geometry (two triangles)
        const positions = new Float32Array([
            // Triangle 1
            0, 0,
            canvas.width, 0,
            0, canvas.height,
            // Triangle 2
            0, canvas.height,
            canvas.width, 0,
            canvas.width, canvas.height
        ]);

        const texCoords = new Float32Array([
            // Triangle 1
            0, 0,
            1, 0,
            0, 1,
            // Triangle 2
            0, 1,
            1, 0,
            1, 1
        ]);

        // Create buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

        // UI Controls
        const scaleSlider = document.getElementById('scaleSlider');
        const timeSlider = document.getElementById('timeSlider');
        const scaleValue = document.getElementById('scaleValue');
        const timeValue = document.getElementById('timeValue');
        const resetBtn = document.getElementById('resetBtn');

        let animationId;
        let startTime = Date.now();

        scaleSlider.addEventListener('input', (e) => {
            scaleValue.textContent = e.target.value;
        });

        timeSlider.addEventListener('input', (e) => {
            timeValue.textContent = e.target.value;
        });

        resetBtn.addEventListener('click', () => {
            scaleSlider.value = '1.0';
            timeSlider.value = '0';
            scaleValue.textContent = '1.0';
            timeValue.textContent = '0.0';
            startTime = Date.now();
        });

        // Render function
        function render() {
            // Clear canvas
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Use program
            gl.useProgram(program);

            // Set uniforms
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, parseFloat(timeSlider.value));
            gl.uniform1f(scaleLocation, parseFloat(scaleSlider.value));

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Bind texture coordinate buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            // Enable blending for antialiasing
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            animationId = requestAnimationFrame(render);
        }

        // Start rendering
        render();

        // Handle window resize
        window.addEventListener('resize', () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            gl.viewport(0, 0, canvas.width, canvas.height);
        });

        console.log('WebGL SDF Demo initialized');
        console.log('- Bezier SDF function ready');
        console.log('- Scene with test curves rendered');
        console.log('- Ready for font parser integration');
    </script>
</body>
</html> 